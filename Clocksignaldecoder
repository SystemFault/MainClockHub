import time
import machine
import utime
from machine import Pin, RTC

class AtomicClockDecoder:
    def __init__(self, signal_pin=4, timezone_offset=0):
        """Initialize the atomic clock decoder.
        
        Args:
            signal_pin: GPIO pin connected to the atomic clock receiver
            timezone_offset: Hours offset from UTC
        """
        self.signal_pin = Pin(signal_pin, Pin.IN)
        self.timezone_offset = timezone_offset
        self.rtc = RTC()
        self.last_edge = 0
        self.bits = []
        self.current_second = 0
        self.time_data = {
            'minute': 0,
            'hour': 0,
            'day': 1,
            'month': 1,
            'year': 2023,
            'weekday': 0
        }
        
        # Set up interrupt on signal pin
        self.signal_pin.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=self._edge_detected)
    
    def _edge_detected(self, pin):
        """Interrupt handler for signal edges"""
        now = utime.ticks_ms()
        duration = utime.ticks_diff(now, self.last_edge)
        self.last_edge = now
        
        # Typical pulse widths for atomic clock signals
        # These values may need adjustment based on your specific signal format
        if 80 <= duration <= 120:
            # ~100ms pulse = 0 bit
            self.bits.append(0)
        elif 180 <= duration <= 220:
            # ~200ms pulse = 1 bit
            self.bits.append(1)
        elif 1800 <= duration <= 2200:
            # ~2000ms pulse = start of new minute
            self._process_frame()
            self.bits = []
            self.current_second = 0
    
    def _process_frame(self):
        """Process a complete frame of data (typically 60 bits for DCF77 or WWVB)"""
        if len(self.bits) < 59:
            print("Incomplete frame, discarding")
            return
        
        # This is a simplification - actual decoding depends on the specific
        # atomic clock protocol (DCF77, WWVB, etc.)
        try:
            # Extract time data from bits (example for DCF77 format)
            minute = self._bcd_to_dec(self.bits[21:28])
            hour = self._bcd_to_dec(self.bits[29:35])
            day = self._bcd_to_dec(self.bits[36:42])
            weekday = self._bcd_to_dec(self.bits[42:45])
            month = self._bcd_to_dec(self.bits[45:50])
            year = 2000 + self._bcd_to_dec(self.bits[50:58])
            
            # Validate time data
            if 0 <= minute <= 59 and 0 <= hour <= 23 and 1 <= day <= 31 and 1 <= month <= 12:
                # Apply timezone offset
                hour = (hour + self.timezone_offset) % 24
                
                # Update RTC
                self.rtc.datetime((year, month, day, weekday, hour, minute, 0, 0))
                print(f"Time synchronized: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}")
                
                # Store current values
                self.time_data = {
                    'minute': minute,
                    'hour': hour,
                    'day': day,
                    'month': month,
                    'year': year,
                    'weekday': weekday
                }
        except Exception as e:
            print(f"Error decoding time data: {e}")
    
    def _bcd_to_dec(self, bits):
        """Convert BCD bits to decimal"""
        result = 0
        factor = 1
        
        for i in range(len(bits) - 1, -1, -1):
            if i % 4 == 3:
                factor = 1
            
            if bits[i]:
                result += factor
            
            factor *= 2
            if factor > 8:
                factor = 10
                
        return result
    
    def set_timezone(self, offset):
        """Set the timezone offset in hours from UTC"""
        self.timezone_offset = offset
        
        # Update current time with new timezone
        dt = self.rtc.datetime()
        hour = (dt[4] - self.timezone_offset + offset) % 24
        self.rtc.datetime((dt[0], dt[1], dt[2], dt[3], hour, dt[5], dt[6], dt[7]))
        print(f"Timezone set to UTC{'+' if offset >= 0 else ''}{offset}")
    
    def get_current_time(self):
        """Get the current time as a formatted string"""
        dt = self.rtc.datetime()
        year, month, day, weekday, hour, minute, second, _ = dt
        return f"{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}"
    
    def display_time(self):
        """Display the current time"""
        print(self.get_current_time())
    
    def run(self):
        """Main loop to update time and handle signal processing"""
        last_second = -1
        while True:
            current_second = utime.time() % 60
            if current_second != last_second:
                last_second = current_second
                if current_second % 10 == 0:  # Display time every 10 seconds
                    self.display_time()
            utime.sleep_ms(100)


# Example usage
if __name__ == "__main__":
    # Create atomic clock decoder with signal on GPIO pin 4 and UTC timezone
    clock = AtomicClockDecoder(signal_pin=4, timezone_offset=0)
    
    # Set timezone to EST (UTC-5)
    # clock.set_timezone(-5)
    
    # Start the main loop
    print("Atomic clock decoder started. Waiting for signal...")
    clock.run()
